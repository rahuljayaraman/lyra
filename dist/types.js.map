{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import { Language, TokenizerConfig } from \"./tokenizer/index.js\";\nimport type { Hooks } from \"./methods/hooks.js\";\nimport type { Node } from \"./radix-tree/node.js\";\n\nexport type TokenScore = [string, number];\nexport type Nullable<T> = T | null;\n\nexport type IIntersectTokenScores = (arrays: TokenScore[][]) => TokenScore[];\n\nexport type ResolveSchema<T extends PropertiesSchema> = {\n  [P in keyof T]: ResolveTypes<T[P]>;\n};\n\nexport type SearchProperties<\n  TSchema extends PropertiesSchema,\n  TKey extends keyof TSchema = keyof TSchema,\n> = TKey extends string\n  ? TSchema[TKey] extends PropertiesSchema\n    ? `${TKey}.${SearchProperties<TSchema[TKey]>}`\n    : TKey\n  : never;\n\nexport type FacetSorting = \"asc\" | \"desc\" | \"ASC\" | \"DESC\";\n\ntype FacetTypeInterfaces = {\n  string: {\n    limit?: number;\n    offset?: number;\n    sort?: FacetSorting;\n  };\n  number: {\n    ranges: {from: number, to: number}[]\n  };\n  boolean: {\n    true?: boolean;\n    false?: boolean;\n  };\n}\n\nexport type FacetsSearch<S extends PropertiesSchema, P extends string = \"\", K extends keyof S = keyof S> = K extends string\n  ? S[K] extends PropertiesSchema\n    ? FacetsSearch<S[K], `${P}${K}.`>\n    : S[K] extends PropertyType\n      ? { [key in `${P}${K}`]?: FacetTypeInterfaces[S[K]] }\n      : never\n  : never;\n\nexport type PropertyType = \"string\" | \"number\" | \"boolean\";\n\nexport type PropertiesSchema = {\n  [key: string]: PropertyType | PropertiesSchema;\n};\n\nexport type AlgorithmsConfig = {\n  intersectTokenScores: IIntersectTokenScores;\n};\n\nexport type PropertiesBoost<S extends PropertiesSchema> = {\n  [P in keyof S]?: number;\n};\n\nexport type ElaspedConfig = {\n  format?: \"human\" | \"raw\",\n}\n\nexport type Configuration<S extends PropertiesSchema> = {\n  /**\n   * The structure of the document to be inserted into the database.\n   */\n  schema: S;\n  /**\n   * The default language analyzer to use.\n   */\n  defaultLanguage?: Language;\n  edge?: boolean;\n  hooks?: Hooks;\n  components?: Components;\n};\n\nexport type Data<S extends PropertiesSchema> = {\n  docs: Record<string, ResolveSchema<S> | undefined>;\n  defaultLanguage: Language;\n  index: Index;\n  schema: S;\n  frequencies: FrequencyMap;\n  tokenOccurrencies: TokenOccurrency;\n  avgFieldLength: Record<string, number>;\n  fieldLengths: Record<string, Record<string, number>>;\n};\n\nexport type Components = {\n  elapsed?: ElaspedConfig;\n  tokenizer?: TokenizerConfig;\n  algorithms?: AlgorithmsConfig;\n};\n\nexport interface Lyra<S extends PropertiesSchema> extends Data<S> {\n  defaultLanguage: Language;\n  schema: S;\n  edge: boolean;\n  hooks: Hooks;\n  components?: Components;\n  frequencies: FrequencyMap;\n  docsCount: number;\n  avgFieldLength: Record<string, number>;\n  fieldLengths: Record<string, Record<string, number>>;\n}\n\nexport type BM25OptionalParams = {\n  k?: number;\n  b?: number;\n  d?: number;\n};\n\nexport type BM25Params = {\n  k: number;\n  b: number;\n  d: number;\n};\n\ntype ResolveTypes<TType> = TType extends \"string\"\n  ? string\n  : TType extends \"boolean\"\n  ? boolean\n  : TType extends \"number\"\n  ? number\n  : TType extends PropertiesSchema\n  ? { [P in keyof TType]: ResolveTypes<TType[P]> }\n  : never;\n\ntype Index = Record<string, Node>;\n\nexport type TokenMap = Record<string, TokenScore[]>;\n\ntype FrequencyMap = {\n  [property: string]: {\n    [documentID: string]: {\n      [token: string]: number;\n    };\n  };\n};\n\ntype TokenOccurrency = {\n  [property: string]: {\n    [token: string]: number;\n  };\n};\n"],"names":[],"mappings":"AAAA,WAkJE"}